#!/bin/bash
#参考:https://github.com/emptyhua/bash-pinyin-completion
#参考:http://linuxtoy.org/archives/chsdir.html
#参考:/etc/bash_completion

#用于保存覆盖之前的函数
#from http://mivok.net/2009/09/20/bashfunctionoverride.html
__logfile=~/command/pinyin.log
__HAS_LOG=1
# __logfile=/dev/null
__MYLOG() {
    if [ "$__HAS_LOG" = "1" ];then
        echo "$@" >> ${__logfile}
    fi
}
_py_save_function() {
    local ORIG_FUNC=$(declare -f $1)
    local NEWNAME_FUNC="$2${ORIG_FUNC#$1}"
    eval "$NEWNAME_FUNC"
}

#兼容旧版本的bash-completion
if test -z "$(typeset -f _compopt_o_filenames)"; then

# This function turns on "-o filenames" behavior dynamically. It is present
# for bash < 4 reasons. See http://bugs.debian.org/272660#64 for info about
# the bash < 4 compgen hack.
_compopt_o_filenames() {
    # We test for compopt availability first because directly invoking it on
    # bash < 4 at this point may cause terminal echo to be turned off for some
    # reason, see https://bugzilla.redhat.com/653669 for more info.
    type compopt &>/dev/null && compopt -o filenames 2>/dev/null || \
        compgen -f /non-existing-dir/ >/dev/null
}

fi

#中文补齐函数

_py_completion() {
    local IFS=$'\t\n'
    local cur dname_real bname_real dname bname tmp tmp2 sep
    local -a list sys_list

    cur="$(_get_cword)"

    dname="$(dirname "$cur")";
    bname="$(basename "$cur")";

    if [[ "${dname:0:1}" == "\"" ]]; then
        dname="${dname:1}"
    fi

    if [[ "${bname:0:1}" == "\"" ]]; then
        bname="${bname:1}"
    fi

    #eval 用于消除转义符 例如 \[ 将变成 [
    dname_real="$dname"
    bname_real="$bname"

    test -z "$bname_real" && return 0;

    if [[ "$dname" == "/" ]];then
        sep=""
    else
        sep="/"
    fi

    test ! -d "$dname_real" && return 0;
    cd $dname_real

    if [[ "$1" == "-d" ]];then
        __MYLOG "has -d"
        list=($(compgen -d|sort|pinyinmatch "$bname_real" $PY_FULL))
    else
        list=($(compgen -f|sort|pinyinmatch "$bname_real" $PY_FULL))
        [ ${#list[@]} -ne 0 ] && _compopt_o_filenames
    fi
    cd $OLDPWD
    sys_list=("${COMPREPLY[@]}")

    __MYLOG dname_real="$dname_real"
    __MYLOG keyword="$bname_real"
    __MYLOG list="${list[@]}"
    __MYLOG  sys_list="${sys_list[@]}"


    if [ ${#list[@]} -eq 1 ];then
        if [ "${list[0]}" = "$bname_real" ];then # 如果关键字和查询出来的是相同，则采取系统的集合
            COMPREPLY=("${sys_list[@]}")
        else
            COMPREPLY=("${list[0]}")
        fi
    elif [[ "${dname_real:0:1}" = "~" ||"${dname_real:0:1}" = "/"  ]];then
        COMPREPLY=()
        for var in "${list[@]}";do
            COMPREPLY=("${COMPREPLY[@]}" "${dname_real}${sep}${var}")
        done
    else
        COMPREPLY=("${list[@]}")
    fi

    # 出去重复的COMPREPLY
    local -a list
    local var var1 found len
    for var in "${COMPREPLY[@]}";do
        found=0
        for var1 in "${list[@]}";do
            if [ "$var" = "$var1" ];then
                found=1
            fi
        done
        if [ "$found" = "0" ];then
            list=( "${list[@]}" "${var}" );
        fi
    done
    __MYLOG list="${list[@]}"

    len=${#list[@]}
    if [ ${len} -eq 1 ];then
        if [ "$dname_real" != "." ];then
            COMPREPLY=( "${dname_real}${sep}${list[0]}" )
        fi
    elif [ ${len} -ne 0 ];then
        COMPREPLY=( "+[1-${len}]选择:" "${list[@]}" )
    fi

    __MYLOG COMPREPLY="${COMPREPLY[@]}"
}

_py_save_function _filedir _py_bak_filedir

_filedir() {
    _py_bak_filedir $@
    _py_completion $@
}

_py_save_function _filedir_xspec _py_bak_filedir_xspec

_filedir_xspec () {
    _py_bak_filedir_xspec $@
    _py_completion $@
}

unset -f _py_save_function
