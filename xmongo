#!/usr/bin/env node

const mongojs = require('mongojs');
const moment = require('moment');
const command = require('./js/command');
const _ = require('lodash');
const shell = require('shelljs');
const DATA_BASE = 'db_smart_plate';
const CACHE = {};
const MOCMD=`mongo 127.0.0.1:27017/${DATA_BASE} --eval`;

let _verbose = true;
let _prettyShell = true;
let _limit = 10;
async function createMongo (commands, options) {
    const db = mongojs(DATA_BASE);
    const tables = await getTables(db);

    let allFileds = [];
    for (const table of tables) {
        const fields = await getFieldsOfTable(db, table);
        allFileds = [...allFileds, ...fields];
    }
    allFileds = _.uniq(allFileds);

    // 添加表，字段的自动完成
    function completer(line) {
        const words = line.replace(/\s,\s/g, ',').trimLeft().split(/\s/);
        const linePartial = _.last(_.last(words).split(','));
        let list = [];
        if (words.length <= 1) {
            const _linePartial = line.trim();
            const _tables = tables.map(o=>`db.${o}`)
            list = _tables.filter((o) => o.startsWith(_linePartial));
            const found = list.filter((o) => o.startsWith(_linePartial));
            return [found.length ? found : list, linePartial];
        }

        const preWord = _.toLower(_.nth(words, -2));
        if (_.includes(['ls', 's', 'm', 'r', 'c'], preWord)) {
            list = tables.filter((o) => o.startsWith(linePartial));
        }  else {
            const prePreWord = _.toLower(_.nth(words, -3));
            if (_.includes(['s', 'm', 'r', 'c'], prePreWord)) {
                const table = preWord;
                const fields = CACHE[table];
                list = fields.filter((o) => o.startsWith(linePartial));
            } else {
                const prePrePreWord = _.toLower(_.nth(words, -4));
                if (_.includes(['s', 'm', 'c'], prePrePreWord)) {
                    const table = prePreWord;
                    const fields = CACHE[table];
                    list = fields.filter((o) => o.startsWith(linePartial));
                } else {
                    list = allFileds.filter((o) => o.startsWith(linePartial));
                }
            }
        }
        const found = list.filter((o) => o.startsWith(linePartial));
        return [found.length ? found : list, linePartial];
    }

    command(commands, { ...options, db, completer });
}
function dropBrack(line) {
    while (_.first(line) === '(' && _.last(line) === ')') {
        line = line.substr(1, line.length-2);
    }
    return line;
}
function parseItem(item) {
    const list = item.match(/(\w+)(!==|!=|>=|>|==|<=|<|=|~|#)(.*)/);
    if (!list) {
        return null;
    }
    const key = list[1];
    const oper = list[2];
    let value = list[3];

    if (key === undefined || oper === undefined || value === undefined) {
        return null;
    }
    if (value === 'null') {
        value = null;
    } else if (+value == value) {
        value = +value
    }

    switch (oper) {
        case '!=':return { [key]: { $ne: value } };
        case '!==':return { [key]: { $ne: value } };
        case '>': return { [key]: { $gt: value } };
        case '>=': return { [key]: { $gte: value } };
        case '==':
        case '=': {
            if (oper === '==') {
                return { [key]: value };
            }
            if (/^[a-z0-9]{24}$/.test(value)) {
                return mongojs.ObjectId(value);
            }
            const values = [];
            if (typeof value === 'number') {
                values.push('' + value);
            } else if (+value == value) {
                values.push(+value);
            }
            if (values.length) {
                values.push(value);
                return { [key]: { $in: values } };
            }
            return { [key]: value };
        }
        case '<': return { [key]: { $lt: value } };
        case '<=': return { [key]: { $lte: value } };
        case '~': {
            value = ''+value;
            return { [key]: new RegExp(value.replace(/</, '^').replace(/>/, '$')) };
        }
        case '#': {
            const list = value.split(',');
            const _list = [];
            for (const item of list) {
                if (/^['"].*['"]$/.test(item)) {
                    _list.push(item.replace(/^['"](.*)['"]$/, '$1'));
                } else if (+item == item) {
                    _list.push(+item);
                } else {
                    _list.push(item);
                }
            }
            return { [key]: { $in: _list } };
        }
    }
    return null;
}
function parseAnd(line) {
    if (!/\||&/.test(line)) {
        return parseItem(line);
    }
    const list = [];
    let i = -1, max = line.length - 1, item = '', match = 0;
    while (i++ < max) {
        const ch = line[i];
        if (ch === '(') {
            match++;
        } else if (ch === ')') {
            match--;
        }
        if (ch === '&' && match === 0) {
            list.push(parseAnd(dropBrack(item)));
            item='';
        } else {
            item=`${item}${ch}`;
        }
    }
    if (match === 0) { // 如果括号不匹配，则丢弃
        if (line === item) {
            item && list.push(parseOr(dropBrack(item)));
        } else {
            item && list.push(parseAnd(dropBrack(item)));
        }
    }
    return list.length > 1 ? { $and: list } : list[0];
}
function parseOr(line) {
    if (!/\||&/.test(line)) {
        return parseItem(line);
    }
    const list = [];
    let i = -1, max = line.length - 1, item = '', match = 0;
    while (i++ < max) {
        const ch = line[i];
        if (ch === '(') {
            match++;
        } else if (ch === ')') {
            match--;
        }
        if (ch === '|' && match === 0) {
            list.push(parseOr(dropBrack(item)));
            item='';
        } else {
            item=`${item}${ch}`;
        }
    }
    if (match === 0) { // 如果括号不匹配，则丢弃
        if (line === item) {
            item && list.push(parseAnd(dropBrack(item)));
        } else {
            item && list.push(parseOr(dropBrack(item)));
        }
    }
    return list.length > 1 ? { $or: list } : list[0];
}
function formatCond(line) {
    if (!line) {
        return {};
    }
    return parseOr(dropBrack(line));
}
function formatResult(obj) {
    if (obj instanceof Array) {
        return obj.map(o=>formatResult(o));
    }
    for (const key in obj) {
        const item = obj[key];
        if (item instanceof Date) {
            obj[key] = moment(item).format('YYYY-MM-DD HH:mm:ss');
        }
    }
    return obj;
}
// 转化 [] 和  {} 中的逗号
function replaceUpdateLine(line) {
    let i = -1, max = line.length - 1, newLine = '', amatch = 0, bmatch = 0;
    while (i++ < max) {
        let ch = line[i];
        if (ch === '[') {
            amatch++;
        } else if (ch === ']') {
            amatch--;
        }
        if (ch === '{') {
            bmatch++;
        } else if (ch === '}') {
            bmatch--;
        }
        if ((amatch > 0 || bmatch > 0) && ch===',') {
            ch='&comma;';
        }
        newLine=`${newLine}${ch}`;
    }
    return newLine;
}
function formatUpdate(doc, line) {
    if (!line) {
        return { $set: {} };
    }
    line = replaceUpdateLine(line);

    let list = line.split(',').filter(o=>o);
    if (!list.length) {
        return { $set: {} };
    }
    const set = {};
    const unset = {};
    for (const item of list) {
        const items = item.split('=');
        const key = items[0];
        let value = items[1]||'';
        value = value.replace(/&comma;/g, ',');
        if (value === 'true') {
            set[key] = true;
            continue;
        }
        if (value === 'false') {
            set[key] = false;
            continue;
        }
        if (value === 'null') {
            set[key] = null;
            continue;
        }
        if (value === '$unset') {
            unset[key] = 1;
            continue;
        }
        const matches = _.uniq(value.match(/\$\w+/g));
        for (const match of matches) {
            const refValue =  doc[match.replace('$', '')];
            if (refValue != undefined) {
                value = value.replace(new RegExp(match.replace('$', '\\$'), 'g'), refValue);
            }
        }
        if (/\+|-|\*|\//.test(value)) {
            try {
                value = eval(value);
            } catch(err) {}
        }
        if (+value == value) {
            value = +value
        } else if (/^['"].*['"]$/.test(value)) {
            value = value.replace(/^['"](.*)['"]$/, '$1');
        }
        set[key] = value;
    }
    return { ...(_.size(set) ? { $set: set } : {}), ...(_.size(unset) ? { $unset: unset } : {}) };
}
async function formatFields(db, table, line) {
    if (!line || line === '*') {
        return {};
    }
    let include = true;
    if (line[0] === '-') {
        include = false;
        line = line.substr(1);
    }
    let list = line.split(',').filter(o=>o);
    const allFields = await getFieldsOfTable(db, table);
    list = list.map(o => new RegExp(o.replace('<', '^').replace('>', '$'), 'i'));

    const fields = {};
    allFields.filter(o=>_.some(list, r=>r.test(o))).forEach(o=>fields[o] = include ? 1 : 0);
    return fields;
}
async function formatSort(db, table, line) {
    if (!line) {
        return {};
    }
    const sort = {};
    const allFields = await getFieldsOfTable(db, table);
    line = line.split(',');
    for (const i in line) {
        let item = line[i];
        let order = 1;
        if (item[0] === '-') {
            item = item.substr(1);
            order = -1;
        }
        if (_.includes(allFields, item)) {
            sort[item] = order;
        }
    }
    return sort;
}
function formatLine(self, line) {
    let i = -1, max = line.length - 1, newLine = '', amatch = 0, bmatch = 0, cmatch = 0;
    while (i++ < max) {
        let ch = line[i];
        if (ch === '[') {
            amatch++;
        } else if (ch === ']') {
            amatch--;
        }
        if (ch === '{') {
            bmatch++;
        } else if (ch === '}') {
            bmatch--;
        }
        if (ch === '(') {
            cmatch++;
        } else if (ch === ')') {
            cmatch--;
        }
    }
    if (amatch || bmatch || cmatch) {
        self.error('括号不匹配');
        return [];
    }
    return line
    .replace(/"[^"]+"/g, o=>o.replace(' ', '&nbsp;'))
    .replace(/'[^']+'/g, o=>o.replace(' ', '&nbsp;'))
    .replace(/\s,\s/g, ',')
    .replace(/\s!=\s/g, '!=')
    .replace(/\s!==\s/g, '!==')
    .replace(/\s=\s/g, '=')
    .replace(/\s==\s/g, '==')
    .replace(/\s~\s/g, '~')
    .replace(/\s\|\s/g, '|')
    .replace(/\s&\s/g, '&')
    .replace(/\s#\s/g, '#')
    .trim().split(/\s/).filter(o=>o).map(o=>o.replace('&nbsp;', ' '));
}
function j2s(obj) {
    return JSON.stringify(obj, (k, v)=>{
        if (v instanceof RegExp) {
            return v.toString();
        }
        return v;
    });
}
function getCollectionNames(db) {
    return new Promise(resolve=>{
        db.getCollectionNames((err, collections)=>{
            if (err) {
                resolve([]);
            } else {
                resolve(collections);
            }
        });
    });
}
function getFields(db, table) {
    return new Promise(resolve=>{
        db[table].find().limit(100).toArray((err, docs)=>{
            if (err) {
                resolve([]);
            } else {
                resolve(_.keys(_.reduce(docs, (r, o)=>({...r, ...o}), {})));
            }
        });
    });
}
async function getTables(db) {
    if (!CACHE._tables) {
        CACHE._tables = await getCollectionNames(db);
    }
    return CACHE._tables;
}
async function getFieldsOfTable(db, table) {
    if (!CACHE[table]) {
        CACHE[table] = await getFields(db, table);
    }
    return CACHE[table];
}
async function nativeMongo(self, line) {
    return new Promise(resolve=>{
        if (!line) {
            resolve();
        }
        if (self && _verbose) {
            self.verbose(`${MOCMD} "${line}"`)
        }
        line = line.replace(/\$/g, '\\$');
        shell.exec(`${MOCMD} "${line}"`, { silent:true }, (code, stdout, stderr) => {
            if (stderr) {
                resolve();
            } else if (stdout) {
                const list = stdout.split('\n').filter(o=>o && !/MongoDB|connecting|Implicit/.test(o));
                if (!list.length) {
                    return resolve();
                }
                for (let item of list) {
                    item = item.replace(/ObjectId\(([^)]*)\)/g, '$1');
                    item = item.replace(/NumberLong\(([^)]*)\)/g, '$1');
                    item = item.replace(/ISODate\(([^)]*)\)/g, '$1');
                    let ret;
                    try {
                        ret = JSON.parse(item);
                    } catch (e) {}
                    resolve(ret);
                }
            }
        });
    });
}
async function executeLine(line, { db }) {
    if (!/^db\./.test(line)) {
        return this.prompt();
    }
    const ret = await nativeMongo(this, line);
    if (!ret) {
        return this.prompt();
    }
    showJson(this, ret);
}
function showJson(self, docs) {
    self.showJson(formatResult(docs), _prettyShell);
}
async function showTables(line, { db }) {
    if (!line) { // show tables
        this.print('tables in '+ DATA_BASE +' :', 'red');
        const tables = await getTables(db);
        this.print(tables.join('  '), 'green');
        this.prompt();
    } else if (line === '-') { // show databases
        this.print('databases :', 'red');
        const dbs = await nativeMongo('db.getMongo().getDBs().databases.map(o=>o.name)');
        this.print(dbs.join('  '), 'green');
        this.prompt();
    } else { // show table fields
        line = line.replace(/[^\w]*/g, '');
        const fields = await getFieldsOfTable(db, line);
        this.print(fields.join('  '), 'green');
        this.prompt();
    }
}
async function showTableLines (line, { db }) {
    let list = formatLine(this, line);
    const table = list[0];
    if (!table) {
        return this.error('invalid oper');
    }
    list = _.drop(list);

    let limit = 0;
    let limitIndex = _.findIndex(list, o=>+o==o);
    if (limitIndex !== -1) {
        limit = +list[limitIndex];
        list.splice(limitIndex, 1);
    } else {
        limit = _limit;
    }

    let cond = {};
    let condIndex = _.findIndex(list, o=>/!=|>=|>\w|=|<=|<\w|~|#/.test(o));
    if (condIndex !== -1) {
        cond = formatCond(list[condIndex]);
        list.splice(condIndex, 1);
    }

    let _fields, _sort;
    if (list.length == 1) {
        _fields = list[0];
    } else if (list.length > 1) {
        _fields = list[0];
        _sort = list[1];
    }
    const fields = await formatFields(db, table, _fields);
    const sort = await formatSort(db, table, _sort);

    if (_verbose) {
        this.verbose(`db.${table}.find(${j2s(cond)}, ${j2s(fields)}).sort(${j2s(sort)}).limit(${limit})`);
    }
    db[table].find(cond, fields).sort(sort).limit(limit).toArray((err, docs)=>{
        if (err) {
            this.print('no record', 'red');
        } else {
            showJson(this, docs);
        }
    });
}
async function modifyTable(line, { db }) {
    let list = formatLine(this, line);
    const table = list[0];
    if (!table) {
        return this.error('invalid oper');
    }
    list = _.drop(list);

    let limit = 0;
    let limitIndex = _.findIndex(list, o=>+o==o);
    if (limitIndex !== -1) {
        limit = +list[limitIndex];
        list.splice(limitIndex, 1);
    } else {
        limit = _limit;
    }

    const setFields = list[0];
    if (!setFields) {
        return this.error('invalid oper');
    }
    list = _.drop(list);

    let cond = {};
    let condIndex = _.findIndex(list, o=>/!=|>=|>\w|=|<=|<\w|~|#/.test(o));
    if (condIndex !== -1) {
        cond = formatCond(list[condIndex]);
        list.splice(condIndex, 1);
    }

    const sort = await formatSort(table, list[0]);

    if (_verbose) {
        this.verbose(j2s(cond));
    }
    db[table].find(cond).sort(sort).limit(limit).toArray((err, docs)=>{
        if (err || !docs.length) {
            this.print('no record', 'red');
            this.prompt();
        } else {
            for (const doc of docs) {
                this.verbose(list[0]);
                const update = formatUpdate(doc, setFields);
                if (!update) {
                    continue;
                }
                if (_verbose) {
                    this.verbose(`db.${table}.update(${doc._id}, ${j2s(update)}).limit(${+limit})`);
                }
                db[table].findAndModify({
                    query: { _id: doc._id },
                    update,
                    new: true
                }, (err, ret) => {
                    if (err) {
                        this.print(err, 'red');
                    } else {
                        showJson(this, ret);
                    }
                });
            }
        }
    });
}
async function removeTable(line, { db }) {
    let list = formatLine(this, line);
    const table = list[0];
    if (!table) {
        return this.error('invalid oper');
    }
    list = _.drop(list);

    let limit = '';
    let limitIndex = _.findIndex(list, o=>+o==o);
    if (limitIndex !== -1) {
        limit = +list[limitIndex];
        limit = limit ? `LIMIT ${limit}` : '';
        list.splice(limitIndex, 1);
    } else {
        limit = `LIMIT ${_limit}`;
    }

    let cond = {};
    let condIndex = _.findIndex(list, o=>/!=|>=|>\w|=|<=|<\w|~|#/.test(o));
    if (condIndex !== -1) {
        cond = formatCond(list[condIndex]);
        list.splice(condIndex, 1);
    }

    const sort = await formatSort(table, list[0]);

    if (_verbose) {
        this.verbose(`db.${table}.remove(${j2s(cond)}).limit(${limit})`);
    }
    db[table].find(cond).sort(sort).limit(limit).toArray((err, docs)=>{
        if (err) {
            this.print(err, 'red');
        } else {
            if (!docs.length) {
                this.prompt();
            }
            for (const doc of docs) {
                db[table].remove({ _id: doc._id }, true, (err, ret) => {
                    if (err) {
                        this.print(err, 'red');
                    } else {
                        showJson(this, ret);
                    }
                });
            }
        }
    });
}
async function copyTableRows(line, { db }) {
    let list = formatLine(this, line);
    const table = list[0];
    if (!table) {
        return this.error('invalid oper');
    }
    list = _.drop(list);

    let limit = '';
    let limitIndex = _.findIndex(list, o=>+o==o);
    if (limitIndex !== -1) {
        limit = +list[limitIndex];
        limit = limit ? `LIMIT ${limit}` : '';
        list.splice(limitIndex, 1);
    } else {
        limit = `LIMIT ${_limit}`;
    }

    let sort = '';
    let sortIndex = _.findIndex(list, o=>/^-?\w+$/.test(o));
    if (sortIndex !== -1) {
        sort = formatCond(list[sortIndex]);
        list.splice(sortIndex, 1);
    }

    let _cond = {};
    let setFields = '';
    if (!list[1]) {
        setFields = '';
        _cond = list[0];
    } else {
        setFields = list[0];
        _cond = list[1];
    }

    if (_verbose) {
        this.verbose(`db.${table}.copy(${j2s(cond)}).to(${j2s(update)}).sort(${j2s(sort)}).limit(${limit})`);
    }
    db[table].find(cond).sort(sort).limit(limit).toArray((err, docs)=>{
        if (err) {
            this.print('no record', 'red');
        } else {
            if (!docs.length) {
                this.prompt();
            }
            for (const doc of docs) {
                const { _id, ..._doc } = doc;
                db[table].save(_doc, (err, ret) => {
                    if (err) {
                        this.print(err, 'red');
                    } else {
                        const update = formatUpdate(_doc, setFields) || {};
                        db[table].findAndModify({
                            query: { _id: ret._id },
                            update,
                            new: true
                        }, (err, ret) => {
                            if (err) {
                                this.print(err, 'red');
                            } else {
                                showJson(this, ret);
                            }
                        });
                    }
                });
            }
        }
    });
}
function togglePrettyShell() {
    _prettyShell = !_prettyShell;
    this.print('pretty format change to ' + _prettyShell);
    this.prompt();
}
function toggleVerbose() {
    _verbose = !_verbose;
    this.print('verbose format change to ' + _verbose);
    this.prompt();
}
function setDefaultLimit(line) {
    _limit = +line || 10;
    this.print('set limit to ' + _limit);
    this.prompt();
}
function showHelp () {
    this.print('commands:', 'blue');
    this.print('    <h|help>: show help');
    this.print('    <q|exit>: exit');
    this.print('    ls: showTables|ls -: showDatabases|ls table: showTableFields');
    this.print('    s(show): showTableLines # s table f1,f2>,<f3> (f1=xx&f2=yy)|f3=zz|f4~<xx>|f5#1,2,3 limit [-]xx');
    this.print('    m(modify): modifyTable # m table f1=xx,f2=xx (f1=xx&f2=yy)|f3=zz|f4~<xx>|f5#1,2,3 limit [-]xx');
    this.print('    r(remove): removeTable # r table (f1=xx&f2=yy)|f3=zz|f4~<xx>|f5#1,2,3 limit [-]xx');
    this.print('    c(copy): copyTableRows # c table f1=$f1+1,f2=xx (f1=xx&f2=yy)|f3=zz|f4~<xx>|f5#1,2,3 limit [-]xx');
    this.print('    _: togglePrettyShell');
    this.print('    v: toggleVerbose');
    this.print('    limit: setDefaultLimit');
    this.print('');
    this.prompt();
}
const COMMANDS = {
    'h|help': showHelp,
    'q|exit': function () { this.close() },
    'cls': function() { this.clear() },
    'ls': showTables,
    's': showTableLines,
    'm': modifyTable,
    'r': removeTable,
    'c': copyTableRows,
    '-': togglePrettyShell,
    'v': toggleVerbose,
    'limit': setDefaultLimit,
    'default': executeLine,
};

createMongo(COMMANDS, { prompt: 'mongo', history: [ 's', 'm', 'r', 'c' ] });
