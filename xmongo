#!/usr/bin/env node

const mongojs = require('mongojs');
const moment = require('moment');
const command = require('./js/command');
const _ = require('lodash');
const DATA_BASE = 'fang';
const CACHE = {};

let _prettyShell = true;
async function createMongo (commands, options) {
    const db = mongojs(DATA_BASE);
    const tables = await getTables(db);

    // 添加表，字段的自动完成
    function completer(line) {
        const words = line.replace(/\s,\s/g, ',').trimLeft().split(/\s/);
        const linePartial = _.last(_.last(words).split(','));
        let list = [];
        if (words.length <= 1) {
            list = ['db'].filter((o) => o.startsWith(linePartial));
        } else {
            const preWord = _.toLower(_.nth(words, -2));
            if (_.includes(['ls', 's', 'm', 'r', 'c'], preWord)) {
                list = tables.filter((o) => o.startsWith(linePartial));
            }  else {
                const prePreWord = _.toLower(_.nth(words, -3));
                if (prePreWord === 's') {
                    const table = preWord;
                    const fields = CACHE[table];
                    list = fields.filter((o) => o.startsWith(linePartial));
                } else {
                    list = allFileds.filter((o) => o.startsWith(linePartial));
                }
            }
        }
        const found = list.filter((o) => o.startsWith(linePartial));
        return [found.length ? found : list, linePartial];
    }

    command(commands, { ...options, db, completer });
}
function dropBrack(line) {
    while (_.first(line) === '(' && _.last(line) === ')') {
        line = line.substr(1, line.length-2);
    }
    return line;
}
function parseItem(item) {
    const list = item.match(/(\w+)(>=|>|=|<=|<|~|#)(.*)/);
    if (!list) {
        return null;
    }
    const key = list[1];
    const oper = list[2];
    const value = list[3];

    if (key === undefined || oper === undefined || value === undefined) {
        return null;
    }
    switch (oper) {
        case '>':
            return { [key]: { $gt: +value } };
        case '>=':
            return { [key]: { $gte: +value } };
        case '=':
            if (/<|>/.test(value)) {
                return { [key]: new RegExp(value.replace(/</, '^').replace(/>/, '$')) };
            }
            return { [key]: +value == value ? +value : value };
        case '<':
            return { [key]: { $lt: +value } };
        case '<=':
            return { [key]: { $lte: +value } };
        case '~':
            return { [key]: new RegExp(value.replace(/</, '^').replace(/>/, '$')) };
        case '#':
            return { [key]: { $in: value.split(',') } };
    }
    return null;
}
function parseAnd(line) {
    if (!/\||&/.test(line)) {
        return parseItem(line);
    }
    const list = [];
    let i = -1, max = line.length - 1, item = '', match = 0;
    while (i++ < max) {
        const ch = line[i];
        if (ch === '(') {
            match++;
        } else if (ch === ')') {
            match--;
        }
        if (ch === '&' && match === 0) {
            list.push(parseAnd(dropBrack(item)));
            item='';
        } else {
            item=`${item}${ch}`;
        }
    }
    if (match === 0) { // 如果括号不匹配，则丢弃
        if (line === item) {
            item && list.push(parseOr(dropBrack(item)));
        } else {
            item && list.push(parseAnd(dropBrack(item)));
        }
    }
    return list.length > 1 ? { $and: list } : list[0];
}
function parseOr(line) {
    if (!/\||&/.test(line)) {
        return parseItem(line);
    }
    const list = [];
    let i = -1, max = line.length - 1, item = '', match = 0;
    while (i++ < max) {
        const ch = line[i];
        if (ch === '(') {
            match++;
        } else if (ch === ')') {
            match--;
        }
        if (ch === '|' && match === 0) {
            list.push(parseOr(dropBrack(item)));
            item='';
        } else {
            item=`${item}${ch}`;
        }
    }
    if (match === 0) { // 如果括号不匹配，则丢弃
        if (line === item) {
            item && list.push(parseAnd(dropBrack(item)));
        } else {
            item && list.push(parseOr(dropBrack(item)));
        }
    }
    return list.length > 1 ? { $or: list } : list[0];
}
function formatCond(line) {
    return parseOr(dropBrack(line));
}
async function format(self, line, db) {
    const matches = line.match(/select(.*)from\s*(\w+)/);
    if (matches) {
        let list = matches[1].split(/,|\s/).filter(o=>o).join(',');
        const fields = await formatFields(db, matches[2], list);
        line = line.replace(/select.*from/, `select ${fields} from`);
    }
    return line;
}
function formatResult(obj) {
    for (const key in obj) {
        const item = obj[key];
        if (item instanceof Buffer) {
            obj[key] = !!item.readInt8(0);
        } else if (item instanceof Date) {
            obj[key] = moment(item).format('YYYY-MM-DD HH:mm:ss');
        }
    }
    return obj;
}
async function formatFields(db, table, line) {
    if (!line || line === '*') {
        return {};
    }
    let list = line.split(',');
    const allFields = await getFieldsOfTable(db, table);
    list = list.map(o => new RegExp(o.replace('<', '^').replace('>', '$'), 'i'));

    const fields = {};
    allFields.filter(o=>_.some(list, r=>r.test(o))).forEach(o=>fields[o] = 1);
    return fields;
}
function formatLine(line) {
    return line
    .replace(/\s,\s/g, ',')
    .replace(/\s=\s/g, '=')
    .replace(/\s~\s/g, '~')
    .replace(/\s\|\s/g, '|')
    .replace(/\s&\s/g, '&')
    .replace(/\s#\s/g, '#')
    .trim().split(/\s/).filter(o=>o);
}
function getCollectionNames(db) {
    return new Promise(resolve=>{
        db.getCollectionNames((err, collections)=>{
            if (err) {
                resolve([]);
            } else {
                resolve(collections);
            }
        });
    });
}
function getFields(db, table) {
    return new Promise(resolve=>{
        db[table].find().limit(100).toArray((err, docs)=>{
            if (err) {
                resolve([]);
            } else {
                resolve(_.keys(_.reduce(docs, (r, o)=>({...r, ...o}), {})));
            }
        });
    });
}
async function getTables(db) {
    if (!CACHE._tables) {
        CACHE._tables = await getCollectionNames(db);
    }
    return CACHE._tables;
}
async function getFieldsOfTable(db, table) {
    if (!CACHE[table]) {
        CACHE[table] = await getFields(db, table);
    }
    return CACHE[table];
}
async function executeLine(line, { db }) {
    if (!line) {
        return this.prompt();
    }
    line = await format(this, line, db);
    await executeSQL(this, line, db);
}
async function showTables(line, { db }) {
    if (!line) { // show tables
        this.print('tables in '+ DATA_BASE +' :', 'red');
        const tables = await getTables(db);
        this.print(tables.join('  '), 'green');
        this.prompt();
    } else { // show table fields
        line = line.replace(/[^\w]*/g, '');
        const fields = await getFieldsOfTable(db, line);
        this.print(fields.join('  '), 'green');
        this.prompt();
    }
}
async function showTableLines (line, { db }) {
    let list = formatLine(line);
    const table = list[0];
    if (!table) {
        this.error('invalid oper');
        return this.prompt();
    }
    list = _.drop(list);
    let limit = _.last(list);
    if (+limit == limit) {
        list = _.dropRight(list);
        limit = +limit ? `LIMIT ${limit}` : '';
    } else {
        limit = 'LIMIT 1';
    }
    let _fields, _cond;
    if (list.length == 1) {
        if (/>=|>|=|<=|<|~|#/.test(list[0])) {
            _cond = list[0];
        } else {
            _fields = list[0];
        }
    } else if (list.length > 1) {
        _fields = list[0];
        _cond = list[1];
    }
    const fields = await formatFields(db, table, _fields);
    const cond = formatCond(_cond);
    console.log(`SELECT ${JSON.stringify(fields)} FROM ${table} ${JSON.stringify(cond)} ${limit}`, db);
}
async function modifyTable(line, { db }) {
    let list = formatLine(line);
    const table = list[0];
    if (!table) {
        this.error('invalid oper');
        return this.prompt();
    }
    list = _.drop(list);
    let limit = _.last(list);
    if (+limit == limit) {
        list = _.dropRight(list);
        limit = +limit ? `LIMIT ${limit}` : '';
    } else {
        limit = 'LIMIT 1';
    }
    const setFields = list[0];
    if (!setFields) {
        this.error('invalid oper');
        return this.prompt();
    }
    const cond = formatCond(list[1]);
    await executeSQL(this, `UPDATE ${table} SET ${setFields} ${cond} ${limit}`, db);
}
async function removeTable(line, { db }) {
    let list = formatLine(line);
    const table = list[0];
    if (!table) {
        this.error('invalid oper');
        return this.prompt();
    }
    list = _.drop(list);
    let limit = _.last(list);
    if (+limit == limit) {
        list = _.dropRight(list);
        limit = +limit ? `LIMIT ${limit}` : '';
    } else {
        limit = 'LIMIT 1';
    }
    const cond = formatCond(list[0]);
    await executeSQL(this, `DELETE FROM ${table} ${cond} ${limit}`, db);
}
async function copyTableRows(line, { db }) {
    let list = formatLine(line);
    const table = list[0];
    if (!table) {
        this.error('invalid oper');
        return this.prompt();
    }
    list = _.drop(list);
    let limit = _.last(list);
    if (+limit == limit) {
        list = _.dropRight(list);
        limit = +limit ? `LIMIT ${limit}` : '';
    } else {
        limit = 'LIMIT 1';
    }
    let condStr = '';
    let setFields =[];
    if (!list[1]) {
        setFields = [];
        condStr = list[0];
    } else {
        setFields = list[0].split(',').map(o=>o.split('='));
        condStr = list[1];
    }
    const cond = formatCond(condStr);
    const docs = await querySQL(this, db, `SELECT * FROM ${table} ${cond} ${limit}`);
    const fields = await getFieldsOfTable(db, table).filter(o=>o!=='id');
    for (const doc of docs) {
        const values = fields.map(o=>{
            // f1=$f1+1
            const setField = _.find(setFields, m=>m[0]===o);
            if (setField) {
                let setValue = setField[1];
                const matches = setValue.match(/\$\w+/g);
                if (matches) {
                    const tmps = matches.map(o=>o.replace('\$', ''));
                    for (const tmp of tmps) {
                        setValue = setValue.replace('$'+tmp, doc[tmp]);
                    }
                }
                if (/[+-\\*/]/.test(setValue)) {
                    return eval(eval(setValue));
                }
                return setValue;
            }
            const item = doc[o];
            if (item instanceof Date) {
                return 'NULL';
            }
            if (doc[o] !== undefined) {
                return JSON.stringify(doc[o]);
            }
            return 'NULL';
        });
        await executeSQL(this, `INSERT INTO ${table} (${fields.join(',')}) VALUES (${values.join(',')})`, db);
    }
}
function togglePrettyShell() {
    _prettyShell = !_prettyShell;
    this.print('pretty format change to ' + _prettyShell);
    this.prompt();
}
function showHelp () {
    this.print('commands:', 'blue');
    this.print('    <h|help>: show help');
    this.print('    <q|exit>: exit');
    this.print('    ls(l): showTables|ls -: showDatabases|ls table: showTableFields');
    this.print('    s(show): showTableLines # s table f1,f2>,<f3> (f1=xx&f2=yy)|f3=zz|f4~<xx>|f5#1,2,3 limit');
    this.print('    m(modify): modifyTable # m table f1=xx,f2=xx (f1=xx&f2=yy)|f3=zz|f4~<xx>|f5#1,2,3 limit');
    this.print('    r(remove): removeTable # r table (f1=xx&f2=yy)|f3=zz|f4~<xx>|f5#1,2,3 limit');
    this.print('    c(copy): copyTableRows # c table f1=$f1+1,f2=xx (f1=xx&f2=yy)|f3=zz|f4~<xx>|f5#1,2,3 limit');
    this.print('    _: togglePrettyShell');
    this.print('');
    this.prompt();
}
const COMMANDS = {
    'h|help': showHelp,
    'q|exit': function () { this.close() },
    'cls': function() { this.clear() },
    'l|ls': showTables,
    's': showTableLines,
    'm': modifyTable,
    'r': removeTable,
    'c': copyTableRows,
    '-': togglePrettyShell,
    'default': executeLine,
};

createMongo(COMMANDS, { prompt: 'mongo', history: [ 's', 'm', 'r', 'c' ] });
